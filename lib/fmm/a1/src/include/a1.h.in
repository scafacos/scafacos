/* -*- Mode: C; c-basic-offset:4 ; -*- */
/*
 *  Copyright (C) 2010 by Argonne National Laboratory.
 *      See COPYRIGHT in top-level directory.
 */

#if !defined A1_H_INCLUDED
#define A1_H_INCLUDED

/* Keep C++ compilers from getting confused */
#if defined(__cplusplus)
extern "C"
{
#endif /* __cplusplus */

#define A1_SUCCESS 0
#define A1_ERROR   1

/** @file a1.h.in */

/*! \addtogroup a1 A1 Public Interface
 * @{
 */

/* ********************************************************************* */
/*                                                                       */
/*               Enumerations                                            */
/*                                                                       */
/* ********************************************************************* */

/**
 * \brief Thread support within A1.
 *
 * Implementation details:
 *
 * A1_THREAD_SINGLE, A1_THREAD_FUNNELED, A1_THREAD_SERIALIZED and
 * A1_THREAD_MULTIPLE have the same meaning as the MPI descriptors
 * of similar name.
 *
 * \ingroup ENUMS
 *
 */

typedef enum
{
    A1_THREAD_SINGLE,     /**< There is only one thread present. */
    A1_THREAD_FUNNELED,   /**< There are multiple threads present
                               but only the main thread makes A1 calls. */
    A1_THREAD_SERIALIZED, /**< There are multiple threads present and each can make A1 calls,
                               but never simultaneously. */
    A1_THREAD_MULTIPLE    /**< There are multiple threads present and each can make A1 calls. */
} A1_thread_level;

/**
 * \brief Datatype support within A1.
 *
 * \note A1 does not support complex numbers yet.  This is okay because
 *       imaginary numbers don't exist, by definition :-)
 *
 * \ingroup ENUMS
 *
 */

typedef enum
{
    A1_INT32,  /**< int32  */
    A1_INT64,  /**< int64  */
    A1_UINT32, /**< uint32 */
    A1_UINT64, /**< uint64 */
    A1_FLOAT,  /**< single-precision */
    A1_DOUBLE, /**< double-precision */
} A1_datatype_t;

/**
 * \brief A1 boolean.
 *
 * \ingroup ENUMS
 *
 */

typedef enum
{
    A1_TRUE = 1,
    A1_FALSE = 0,
} A1_bool_t;

/**
 * \brief A1 result (error code).
 *
 * \ingroup ENUMS
 *
 */

typedef enum
{
    A1_NO_ERROR = 0, /* Can't use A1_SUCCESS since we're already using that.  Should fix this. */
    A1_MEMORY_ERROR,
    A1_NETWORK_ERROR,
    A1_UNKNOWN_ERROR,
} A1_result_t;

/**
 * \brief A1 reduction operations
 *
 * \ingroup ENUMS
 *
 */

typedef enum
{
    A1_SUM,
    A1_PROD,
    A1_MAX,
    A1_MIN,
    A1_MAXABS, /* Returns MAX(ABS(buffer)) */
    A1_MINABS, /* Returns MIN(ABS(buffer)) */
    A1_OR,     /* should be only for integer types but I don't know if we check */
    A1_BXOR,   /* bit-wise XOR - only for integer types */
    A1_SAME,   /* Sets the return value if the buffer (element) is the same across all nodes.
                  This operation is equivalent to doing MAX(buffer) and MIN(-buffer) simultaneously
                  and testing for equality element-wise. */
} A1_reduce_op_t;

/**
 * \brief A1 RMW operations
 *
 * \ingroup ENUMS
 *
 */

typedef enum
{
    A1_FETCH_AND_ADD,
    A1_SWAP,
} A1_atomic_op_t;

/* ********************************************************************* */
/*                                                                       */
/*               A1 data structures                                      */
/*                                                                       */
/* ********************************************************************* */

/**
 * \brief A1 memregion type.
 *
 * \see A1_Allocate_memregion, A1_Free_memregion, A1_Bind_memregion
 *
 * \ingroup TYPEDEFS
 *
 */

typedef struct A1_memregion
{
    void* base_address;
    unsigned size;           /* Size in elements of type not bytes (unless bytes is type). */
    A1_datatype_t type;      /* Not sure if this is the right idea but one can always use bytes. */
    void* memregion_options; /* This is a pointer to the device-specific memregion options that
                                 are the motivation for creating this struct in the first place. */
} A1_memregion_t;

/**
 * \brief A1 offset type.
 *
 * \see A1_PutMR
 *
 * \ingroup TYPEDEFS
 *
 */

typedef unsigned int A1_offset_t;

/**
 * \brief A1 group type.
 *
 * \see A1_PutMR
 *
 * \ingroup TYPEDEFS
 *
 */

/* TODO: Implement A1 group types.  I wonder if the user-accessible type should be
 *        a pointer to the internal implementation to prevent people from doing
 *        stupid kinds of direct access.
 */
/* FIXME: I really want to use a device-specific implementation of groups
 *         since this is critical for optimizing collectives on Blue Gene
 *         systems.  This also permits shared-memory optimizations in cases
 *         where the group is confined to a single node.  There will also
 *         be quirks arising in the GPU context I want to deal with directly.
 */
typedef struct A1_group
{
    int* rank_list;
} A1_group_t;

A1_group_t a1_group_world;

#define A1_GROUP_WORLD &a1_group_world

/**
 * \brief A1 endpoint type.
 *
 * \see A1_PutMR
 *
 * \ingroup TYPEDEFS
 *
 */

typedef unsigned int A1_endpoint_t;

/**
 * \brief A1 size type.
 *
 * \see A1_PutMR
 *
 * \ingroup TYPEDEFS
 *
 */

typedef unsigned int A1_size_t;

/**
 * \brief A1 non-blocking handle type.
 *
 * \see A1_Test_handle, A1_Test_handle_list,
 *      A1_Wait_handle, A1_Wait_handle_list,
 *      A1_Reset_handle, A1_Reset_handle_list
 *
 * \ingroup TYPEDEFS
 *
 */

typedef void* A1_handle_t;

/**
 * \brief A1 shared counter.
 *
 * \ingroup TYPEDEFS
 *
 */

typedef void* A1_counter_t;

/**
 * \brief A1 io vector type.
 *
 * \see A1_PutV, A1_GetV, A1_PutAccV
 *
 * \ingroup TYPEDEFS
 *
 */

typedef struct A1_iov_t
{
    void **source_ptr_ar;
    void **target_ptr_ar;
    int size; /*In bytes*/
    int ptr_ar_len;
} A1_iov_t;

/* ********************************************************************* */
/*                                                                       */
/*               A1 external API - Helper Functions                      */
/*                                                                       */
/* ********************************************************************* */

/**
 * \brief Timer in units of cycles.
 *
 * \warning This function is not guaranteed to produce correct results for
 *          arbitrarily-long durations (e.g. in the case where the underlying
 *          cycle-accurate counter outputs a 32-bit integer).
 *
 * \param[out] rc   Number of cpu clock cycles from an arbitrary time in the past.
 *
 * \see A1_Time_seconds
 *
 * \ingroup INFORMATION
 */

unsigned long long A1_Time_cycles(void);

/**
 * \brief Timer in units of seconds.
 *
 *
 * \param[out] rc   Number of seconds from an arbitrary time in the past.
 *
 * \see A1_Time_cycles
 *
 * \ingroup INFORMATION
 */

double A1_Time_seconds(void);

/* ********************************************************************* */
/*                                                                       */
/*               A1 external API - Process Information                   */
/*                                                                       */
/* ********************************************************************* */

/**
 * \brief Returns process rank relative to the group base of the process calling it,
 *        or -1 in the case of an error.
 *
 * \note Jeff hates MPI-style function style where return value is an
 *       argument passed by reference for the sake of Fortran compatibility
 *       (or whatever their reason is).
 *
 * \see A1_Node_id, A1_Process_total
 *
 * \ingroup INFORMATION
 */

int A1_Process_id(A1_group_t* group);

/**
 * \brief Returns total number of processes in a group or -1 in the case of an error.
 *
 * \note Jeff hates MPI-style function style where return value is an
 *       argument passed by reference for the sake of Fortran compatibility
 *       (or whatever their reason is).
 *
 * \see A1_Process_id, A1_Node_total
 *
 * \ingroup INFORMATION
 */

int A1_Process_total(A1_group_t* group);

/**
 * \brief Returns node rank relative to the group base of the process calling it,
 *        or -1 in the case of an error.
 *
 * \note Jeff hates MPI-style function style where return value is an argument
 *       passed by reference for the sake of Fortran compatibility.
 *
 * \see A1_Process_id, A1_Node_total
 *
 * \ingroup INFORMATION
 */

int A1_Node_id(A1_group_t* group);

/**
 * \brief Returns total number of nodes in a group, or -1 in the case of an error.
 *
 * \note Jeff hates MPI-style function style where return value is an argument
 *       passed by reference for the sake of Fortran compatibility.
 *
 * \see A1_Node_id, A1_Process_total
 *
 * \ingroup INFORMATION
 */

int A1_Node_total(A1_group_t* group);

/* ********************************************************************* */
/*                                                                       */
/*               A1 external API - management                            */
/*                                                                       */
/* ********************************************************************* */

/**
 * \brief Initializes the Al environment.
 *
 * \warning If the MPID device is used, one should be careful in using A1_Initialize and MPI_Init/MPI_Init_thread.
 *
 * \note Unlike MPI, A1_Initialize may be called many times and but is not thread-safe.
 *       Improper use of A1_Initialize (calling it more than once) shall be
 *       indicated by a non-zero error code and potentially warnings in
 *       stderr.
 *
 * \note Implementation detail: we need global variable indicated where or not
 *       A1 is alive or not to make this function thread-safe.
 *
 * \note This routine is called A1_Initialize for syntactic symmetry with
 *       A1_Finalize and because of Jeff's schadenfreude toward Pavan.
 *
 * \param[out] rc               The error code from initializing A1
 * \param[in]  A1_thread_level  The type of thread support for A1
 *
 * \see A1_thread_level
 *
 * \ingroup MANAGEMENT
 */

int A1_Initialize(int A1_thread_level);

/**
 * \brief Terminates the A1 environment normally.
 *
 * \warning If the MPID device is used, one should be careful in using A1_Finalize and MPI_Finalize.
 *
 * \note Unlike MPI, A1_Finalize may be called many times and is thread-safe.
 *       Improper use of A1_Finalize (calling it more than once) shall be
 *       indicated by a non-zero error code and potentially warnings in
 *       stderr.
 *
 * \note Implementation detail: we need global variable indicated where or not
 *       A1 is alive or not to make this function thread-safe.
 *
 * \param[out] rc    The error code from terminating A1.
 *
 * \see A1_Initialize, A1_Abort
 *
 * \ingroup MANAGEMENT
 */

int A1_Finalize(void);

/**
 * \brief Terminates the A1 environment abnormally.
 *
 * \warning This must be the last A1 call made in any code unless A1_Finalize is called instead.
 *
 * \param[in]  error_code    The error code to be returned to the submitting environment.
 * \param[in]  error_message Text string to print to stderr upon termination.
 *
 * \see A1_Initialize, A1_Finalize
 *
 * \ingroup MANAGEMENT
 */

void A1_Abort(int error_code, char error_message[]);

/* ********************************************************************* */
/*                                                                       */
/*               A1 external API - memory                                */
/*                                                                       */
/* ********************************************************************* */

/**
 * \brief A local operation to allocate memory to be used in context of A1 copy operations.
 *
 * \note Memory allocated with this function will be properly aligned for the architecture.
 *
 * \warning Memory allocated with this function must be freed by A1_Free_segment.
 *
 * \param[out] rc            The error code.
 * \param[out] ptr           Pointer to memregion structure to be created.
 * \param[in]  bytes         The amount of memory requested.
 *
 * \see A1_Free_memregion, A1_Bind_memregion
 *
 * \ingroup MEMORY
 */

int A1_Allocate_memregion(A1_memregion_t* memregion, int bytes);

/**
 * \brief A local operation to free memory allocated by A1_Alloc_segment.
 *
 * \warning It is erroneous to attempt to free memory not allocated by A1_Alloc_segment.
 *
 * \param[out] rc            The error code.
 * \param[in]  memregion     Pointer to memregion structure to be destroyed.
 *
 * \see A1_Alloc_segment, A1_Register_segment
 *
 * \ingroup MEMORY
 */

int A1_Free_memregion(A1_memregion_t* memregion);

/**
 * \brief A local operation to register memory to be used in context of A1 copy operations.
 *
 * \note This call is not necessary for memory allocated with A1_Alloc_segment.
 *
 * \note Memory allocated with this function will be tested for proper alignment and return
 *       an error if alignment checking has been disabled and the pointer is not properly aligned.
 *
 * \note A1_Register_segment will check for valid allocation of the memory provided,
 *       potentially by writing "\0" to all bytes.
 *
 * \note This call may not work in all contexts.  For example, CUDA provides no API call to
 *       register pre-allocated memory.  A truly portable A1 program must not call this
 *       function.
 *
 * \note We can make this call portable if we copy the existing data into the memregion
 *       and free the original buffer, but this is going to have nasty side-effects
 *       if the user doesn't realize this is what is going on.
 *
 * \param[out] rc            The error code.
 * \param[in]  ptr           Pointer to memregion structure to be created.
 * \param[in]  ptr           Pointer to previously-allocated memory.
 * \param[in]  bytes         The amount of memory provided.
 *
 * \see A1_Alloc_segment, A1_Free_segment
 *
 * \ingroup MEMORY
 */

int A1_Bind_memregion(A1_memregion_t* memregion, void** pointer, int bytes);

/**
 * \brief A collective operation to exchange addresses of segments to be used in context of A1 copy operations.
 *
 * \note There is no local de-registration call because that could lead to erroneous programs.
 *       De-registration can only be effected by a call to A1_Release_segments, which is collective.
 *
 * \param[out] rc            The error code.
 * \param[in]  group         Group of processes within which the pointer list is exchanged.
 * \param[in]  ptr           Pointer array. Each one points to memory allocated at one process, in order of ranks.
 * \param[in]  bytes         The size of memory allocated at each process.
 *
 * \see A1_Release_segments
 *
 * \ingroup MEMORY
 */

/* TODO: We should just implement alltoall and eliminate this function from the API. */
int A1_Exchange_memregions(A1_group_t* group, void **ptr);

/**
 * \brief A collective operation to invalidate and de-register memory segments
 *        associated with an A1_Exchange_segments call.
 *
 * \param[out] rc            The error code.
 * \param[in]  group         Group of processes within which the pointer list was exchanged.
 * \param[in]  ptr           Pointer to the allocated memory.
 *
 * \see A1_Exchange_segments
 *
 * \ingroup MEMORY
 */

/**
 * \brief Initializes the give non-blocking handle.
 *
 * \param[in] handle      Non-blocking handle upon which to be waited.
 *
 * \see A1_handle_t, A1_Wait_handle_list, A1_Test_handle
 *
 * \ingroup MEMORY
 */

int A1_Allocate_handle(A1_handle_t *handle);

/**
 * \brief Initializes the give non-blocking handle.
 *
 * \param[in] handle      Non-blocking handle upon which to be waited.
 *
 * \see A1_handle_t, A1_Wait_handle_list, A1_Test_handle
 *
 * \ingroup MEMORY
 */

int A1_Release_handle(A1_handle_t handle);

/**************************************************************************************/
/*    WARNING: THIS PART OF THE API IS DEPRECATED AND WILL BE REMOVED EVENTUALLY      */
/**************************************************************************************/

/**
 * \brief A local operation to allocate memory to be used in context of A1 copy operations.
 *
 * \note Memory allocated with this function will be properly aligned for the architecture.
 *
 * \warning Memory allocated with this function must be freed by A1_Free_segment.
 *
 * \param[out] rc            The error code.
 * \param[out] ptr           Pointer to memory.
 * \param[in]  bytes         The amount of memory requested.
 *
 * \see A1_Free_segment, A1_Register_segment
 *
 * \ingroup MEMORY
 */

int A1_Alloc_segment(void** pointer, int bytes);

/**
 * \brief A local operation to free memory allocated by A1_Alloc_segment.
 *
 * \warning It is erroneous to attempt to free memory not allocated by A1_Alloc_segment.
 *
 * \param[out] rc            The error code.
 * \param[in] ptr           Pointer to memory.
 *
 * \see A1_Alloc_segment, A1_Register_segment
 *
 * \ingroup MEMORY
 */

int A1_Free_segment(void* pointer);

/**
 * \brief A local operation to register memory to be used in context of A1 copy operations.
 *
 * \note This call is not necessary for memory allocated with A1_Alloc_segment.
 *
 * \note Memory allocated with this function will be tested for proper alignment and return
 *       an error if alignment checking has been disabled and the pointer is not properly aligned.
 *
 * \note A1_Register_segment will check for valid allocation of the memory provided,
 *       potentially by writing "\0" to all bytes.
 *
 * \note This call may not work in all contexts.  For example, CUDA provides no API call to
 *       register pre-allocated memory.  A truly portable A1 program must not call this
 *       function.
 *
 * \param[out] rc            The error code.
 * \param[in]  ptr           Pointer to memory.
 * \param[in]  bytes         The amount of memory provided.
 *
 * \see A1_Alloc_segment, A1_Free_segment
 *
 * \ingroup MEMORY
 */

int A1_Register_segment(void** pointer, int bytes);

/**
 * \brief A collective operation to exchange addresses of segments to be used in context of A1 copy operations.
 *
 * \note There is no local de-registration call because that could lead to erroneous programs.
 *       De-registration can only be effected by a call to A1_Release_segments, which is collective.
 *
 * \param[out] rc            The error code.
 * \param[in]  group         Group of processes within which the pointer list is exchanged.
 * \param[in]  ptr           Pointer array. Each one points to memory allocated at one process, in order of ranks.
 * \param[in]  bytes         The size of memory allocated at each process.
 *
 * \see A1_Release_segments
 *
 * \ingroup MEMORY
 */

/* TODO: We should just implement alltoall and eliminate this function from the API. */
int A1_Exchange_segments(A1_group_t* group, void **ptr);

/**
 * \brief A collective operation to invalidate and de-register memory segments
 *        associated with an A1_Exchange_segments call.
 *
 * \param[out] rc            The error code.
 * \param[in]  group         Group of processes within which the pointer list was exchanged.
 * \param[in]  ptr           Pointer to the allocated memory.
 *
 * \see A1_Exchange_segments
 *
 * \ingroup MEMORY
 */

/* TODO: I'm not sure this function is required.  One can get this functionality
 *        by having all processes free their segments and then calling a barrier. */
int A1_Release_segments(A1_group_t* group, void* ptr);

/* ********************************************************************** */
/*                                                                        */
/*               A1 external API - atomic operations                      */
/*                                                                        */
/* ********************************************************************** */

/**
 * \brief Collective operation to allocate and register a counter.
 *
 * \param[out]    rc            The error code.
 * \param[in]     group         A1 group over which the counter is shared.
 * \param[inout]  counter       A1 shared counter.
 *
 * \see a1_counter_t, A1_Destroy_counter, A1_Incr_counter
 *
 * \ingroup Atomics
 */

int A1_Create_counter(A1_group_t* group, A1_counter_t *counter);

/**
 * \brief Collective operation to deallocate and deregister a counter.
 *
 * \param[out]    rc            The error code.
 * \param[in]     group         A1 group over which the counter is shared.
 * \param[inout]  counter       A1 shared counter.
 *
 * \see a1_counter_t, A1_Create_counter, A1_Incr_counter, A1_NbIncr_counter
 *
 * \ingroup Atomics
 */

int A1_Destroy_counter(A1_group_t* group, A1_counter_t *counter);

/* TODO: Does PPC32 (or 32-bit processors in general) support hardware atomics for 64-bit integers???
 *       I would like to use int64_t on all platforms if we can use them on Blue Gene/P.
 */

/**
 * \brief Atomically updates a shared counter and returns the current value.
 *
 * \param[out] rc            The error code.
 * \param[in]  counter       A1 shared counter.
 * \param[in]  increment     The value to add to the counter.
 * \param[in]  original      The remote value of the counter prior to the increment.
 *
 * \see a1_counter_t, A1_Create_counter, A1_Destroy_counter, A1_NbIncr_counter
 *
 * \ingroup Atomics
 */

int A1_Incr_counter(A1_counter_t counter, long increment, long* original);

/**
 * \brief Non-blocking atomic RMW update of a shared counter.
 *
 * \param[out] rc            The error code.
 * \param[in]  counter       A1 shared counter.
 * \param[in]  increment     The value to add to the counter.
 * \param[in]  original      The remote value of the counter prior to the increment.
 * \param[out] handle        Opaque handle for the request
 *
 * \see a1_counter_t, A1_Create_counter, A1_Destroy_counter, A1_Incr_counter
 *
 * \ingroup Atomics
 */

int A1_NbIncr_counter(A1_counter_t counter,
                      long* increment,
                      long* original,
                      A1_handle_t handle);

/**
 * \brief Collective operation to allocate and register a list of mutexes.
 *
 * \param[out]    rc            The error code.
 * \param[in]     group         A1 group over which the mutexes are shared.
 * \param[in]     count         Number of mutexes to be created.
 * \param[int]    count_ar      An arrays storing the number of mutexes on each process
 *
 * \see a1_mutex_t, A1_Destroy_mutexes, A1_Lock_mutex, A1_Trylock_mutex, A1_Unlock_mutex
 *
 * \ingroup Atomics
 */

int A1_Create_mutexes(A1_group_t* group, int mutex_count, int *mutex_count_ar);

/**
 * \brief Collective operation to deallocate and deregister a list of mutexes
 *
 * \note Implementors: A1_mutex_t cannot be dynamically allocated otherwise this function
 *                     will create a memory leak.
 *
 * \param[out]    rc            The error code.
 * \param[in]     group         A1 group over which the mutexes are shared.
 * \param[in]     mutexes       Pointer to vector A1 mutexes.
 *
 * \see a1_mutex_t, A1_Create_mutexes, A1_Lock_mutex, A1_Trylock_mutex, A1_Unlock_mutex
 *
 * \ingroup Atomics
 */

int A1_Destroy_mutexes(A1_group_t* group);

/**
 * \brief Local operation to lock a mutex.  This call blocks until the mutex has been locked.
 *
 * \param[out]    rc            The error code.
 * \param[in]     group         A1 group over which the mutexes are shared.
 * \param[in]     mutex         A1 mutex.
 * \param[in]     proc          Process on which you want to lock mutex on
 *
 * \see a1_mutex_t, A1_Trylock_mutex, A1_Unlock_mutex, A1_Create_mutexes, A1_Destroy_mutex, A1_Trylock_mutex, A1_Unlock_mutex
 *
 * \ingroup Atomics
 */

int A1_Lock_mutex(A1_group_t* group, int mutex, int proc);

/**
 * \brief Local operation to trylock a mutex.
 *
 * \param[out]    rc            The error code.
 * \param[in]     group         A1 group over which the mutexes are shared.
 * \param[in]     mutex         A1 mutex.
 * \param[in]     proc          Process on which you want to lock mutex on
 *
 * \see a1_mutex_t, A1_Lock_mutex, A1_Unlock_mutex, A1_Create_mutexes, A1_Destroy_mutex, A1_Trylock_mutex, A1_Unlock_mutex
 *
 * \ingroup Atomics
 */

int A1_Trylock_mutex(A1_group_t* group, int mutex, int proc, A1_bool_t *acquired);

/**
 * \brief Local operation to unlock a mutex.  This call blocks until the mutex has been unlocked.
 *
 * \param[out]    rc            The error code.
 * \param[in]     group         A1 group over which the mutexes are shared.
 * \param[in]     mutex         A1 mutex.
 * \param[in]     proc          Process on which you want to lock mutex on
 *
 * \see a1_mutex_t, A1_Lock_mutex, A1_Trylock_mutex, A1_Create_mutexes, A1_Destroy_mutex, A1_Trylock_mutex, A1_Unlock_mutex
 *
 * \ingroup Atomics
 */

int A1_Unlock_mutex(A1_group_t* group, int mutex, int proc);

/**
 * \brief Local operation to lock a list of mutexes.  This call blocks until ALL
 *        mutexes have been locked.
 *
 * \param[out]    rc            The error code.
 * \param[in]     group         A1 group over which the mutexes are shared.
 * \param[in]     count         Number of mutexes to be locked.
 * \param[in]     mutexes       Pointer to vector A1 mutexes.
 * \param[in]     proc          Pointer to vector or process ranks.
 *
 * \see a1_mutex_t, A1_Create_mutexes, A1_Destroy_mutex, A1_Trylock_mutex, A1_Unlock_mutex
 *
 * \ingroup Atomics
 */

int A1_Lock_mutexes(A1_group_t* group, unsigned count, int *mutexes, int *procs);

/**
 * \brief Local operation to trylock a list of mutexes.  This call attempts to acquire all the
 *        locks given and sets the value of the corresponding offset in a vector of booleans
 *        indicating if the lock was acquired or not.
 *
 * \param[out]    rc            The error code.
 * \param[in]     group         A1 group over which the mutexes are shared.
 * \param[in]     count         Number of mutexes to be locked.
 * \param[in]     mutexes       Pointer to vector A1 mutexes.
 * \param[inout]  acquired      Pointer to vector A1 booleans indicating if the lock was acquired.
 *
 * \see a1_mutex_t, A1_Create_mutexes, A1_Destroy_mutex, A1_Trylock_mutex, A1_Unlock_mutex
 *
 * \ingroup Atomics
 */

int A1_Trylock_mutexes(A1_group_t* group, unsigned count, int *mutexes, int *procs, A1_bool_t* *acquired);

/**
 * \brief Local operation to unlock a list of mutexes
 *
 * \param[out]    rc            The error code.
 * \param[in]     group         A1 group over which the mutexes are shared.
 * \param[in]     count         Number of mutexes to be locked.
 * \param[in]     mutexes       Pointer to vector A1 mutexes.
 *
 * \see a1_mutex_t, A1_Create_mutexes, A1_Destroy_mutex, A1_Trylock_mutex, A1_Unlock_mutex
 *
 * \ingroup Atomics
 */

int A1_Unlock_mutexes(A1_group_t* group, unsigned count, int *mutexes, int *procs);

/* FIXME: More API functions to come */

/* ********************************************************************** */
/*                                                                        */
/*               A1 external API - data transfer operations               */
/*                                                                        */
/* ********************************************************************** */

/**************************************************************************************/
/*    WARNING: THIS IS THE NEW API AND IS NOT YET IMPLEMENTED                         */
/**************************************************************************************/
/**
 * \brief Blocking copy of contiguous data from local memory to remote memory.
 *
 * \param[out] rc               The error code.
 * \param[in]  target           Rank of the remote endpoint.
 * \param[in]  source_mr        Source (local) memory region.
 * \param[in]  source_offset    Offset into source (local) memory region.
 * \param[in]  target_mr        Target (remote) memory region.
 * \param[in]  target_offset    Offset into target (remote) memory region.
 * \param[in]  bytes            Amount of data to transfer in bytes.
 *
 * \see A1_Put
 *
 * \ingroup DATA_TRANSFER
 */

/* int A1_PutMR(A1_endpoint_t target, */
/*             A1_memregion_t* source_mr, */
/*             A1_offset_t source_offset, */
/*             A1_memregion_t* target_mr, */
/*             A1_offset_t target_offset, */
/*             A1_size_t bytes); */

/**************************************************************************************/
/*    WARNING: THIS PART OF THE API IS DEPRECATED AND WILL BE REMOVED EVENTUALLY      */
/**************************************************************************************/

/**
 * \brief Blocking copy of contiguous data from local memory to remote memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (local) source memory.
 * \param[in]  target_ptr    Starting address in the (remote) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 *
 * \see A1_NbPut, A1_MultiPut
 *
 * \ingroup DATA_TRANSFER
 */

int A1_Put(int target, void* source_ptr, void* target_ptr, int bytes);

/**
 * \brief Non-Blocking copy of contiguous data from local memory to remote memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (local) source memory.
 * \param[in]  target_ptr    Starting address in the (remote) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 * \param[out] handle        Opaque handle for the request
 *
 * \see A1_Put, A1_NbMultiPut
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbPut(int target,
             void* source_ptr,
             void* target_ptr,
             int bytes,
             A1_handle_t handle);

/**
 * \brief Blocking copy of contiguous data from local memory to remote memory.
 *
 * \note A1_MultiPut can be used for single-target non-contiguous put as well,
 *       but the implementation may be far from optimal relative to A1_PutS
 *       and A1_PutV.
 *
 * \param[out] rc            The error code.
 * \param[in]  count         Number of operations to be performed
 * \param[in]  targets       Vector of remote process ranks.
 * \param[in]  source_ptr    Vector of starting addresses in the (local) source memory.
 * \param[in]  target_ptr    Vector of starting addresses in the (remote) target memory.
 * \param[in]  bytes         Vector of quantity of data to transfer in bytes.
 *
 * \see A1_Put
 *
 * \ingroup DATA_TRANSFER
 */

int A1_MultiPut(int count,
                int *targets,
                void* *source_ptr,
                void* *target_ptr,
                int *bytes);

/**
 * \brief Nonblocking copy of contiguous data from local memory to remote memory.
 *
 * \note A1_MultiPut can be used for single-target non-contiguous put as well,
 *       but the implementation may be far from optimal relative to A1_PutS
 *       and A1_PutV.
 *
 * \param[out] rc            The error code.
 * \param[in]  count         Number of operations to be performed
 * \param[in]  targets       Vector of remote process ranks.
 * \param[in]  source_ptr    Vector of starting addresses in the (local) source memory.
 * \param[in]  target_ptr    Vector of starting addresses in the (remote) target memory.
 * \param[in]  bytes         Vector of quantity of data to transfer in bytes.
 *
 * \see A1_NbPut, A1_MultiPut
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbMultiPut(int count,
                  int *targets,
                  void* *source_ptr,
                  void* *target_ptr,
                  int *bytes,
                  A1_handle_t handle);

/**
 * \brief Blocking copy of strided data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  count           Block size in each dimension in bytes.
 * \param[in]  stride_levels   The number of levels of stride.
 * \param[in]  source_ptr      Starting address in the (local) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at source in bytes.
 * \param[in]  target_ptr      Starting address in the (remote) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at target in bytes.
 *
 * \see A1_Put, A1_PutV, A1_MultiPut, A1_MultiPutS, A1_MultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_PutS(int target,
            int stride_levels,
            int *block_sizes,
            void* source_ptr,
            int *src_stride_ar,
            void* target_ptr,
            int *trg_stride_ar);

/**
 * \brief Non-Blocking copy of strided data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  count           Block size in each dimension in bytes.
 * \param[in]  stride_levels   The number of levels of stride.
 * \param[in]  source_ptr      Starting address in the (local) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at source in bytes.
 * \param[in]  target_ptr      Starting address in the (remote) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at target in bytes.
 * \param[out] handle          Opaque A1 handle
 *
 * \see A1_NbPut, A1_NbPutV, A1_NbMultiPut, A1_NbMultiPutS, A1_NbMultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbPutS(int target,
              int stride_levels,
              int *block_sizes,
              void* source_ptr,
              int *src_stride_ar,
              void* target_ptr,
              int *trg_stride_ar,
              A1_handle_t handle);

/**
 * \brief Blocking copy of contiguous data from local memory to remote memory.
 *
 * \note This call must be use the same stride-level across all targets.
 *
 * \param[out] rc              The error code.
 * \param[in]  count           Number of operations to be performed
 * \param[in]  targets         Vector of remote process ranks.
 * \param[in]  block_sizes     Vector of block sizes in each dimension in bytes.
 * \param[in]  stride_levels   Number of levels of stride.
 * \param[in]  source_ptr      Vector of starting in the (local) source memory.
 * \param[in]  src_stride_ar   Vector of arrays of stride distances at source in bytes.
 * \param[in]  target_ptr      Vector of starting in the (remote) target memory.
 * \param[in]  trg_stride_ar   Vector of arrays of stride distances at target in bytes.
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_MultiPutS(int count,
                 int *targets,
                 int stride_levels,
                 int* *block_sizes,
                 void* source_ptr,
                 int *src_stride_ar,
                 void* target_ptr,
                 int *trg_stride_ar);

/**
 * \brief Nonblocking copy of contiguous data from local memory to remote memory.
 *
 * \note This call must be use the same stride-level across all targets.
 *
 * \param[out] rc              The error code.
 * \param[in]  count           Number of operations to be performed
 * \param[in]  targets         Vector of remote process ranks.
 * \param[in]  block_sizes     Vector of block sizes in each dimension in bytes.
 * \param[in]  stride_levels   Number of levels of stride.
 * \param[in]  source_ptr      Vector of starting in the (local) source memory.
 * \param[in]  src_stride_ar   Vector of arrays of stride distances at source in bytes.
 * \param[in]  target_ptr      Vector of starting in the (remote) target memory.
 * \param[in]  trg_stride_ar   Vector of arrays of stride distances at target in bytes.
 * \param[out] handle          Opaque A1 handle
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbMultiPutS(int count,
                   int *targets,
                   int stride_levels,
                   int* *block_sizes,
                   void* source_ptr,
                   int *src_stride_ar,
                   void* target_ptr,
                   int *trg_stride_ar,
                   A1_handle_t handle);

/**
 * \brief Blocking copy of non-contiguous data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  iov_ar          Array of io vectors. Each vector represents a set of chunks of same size.
 * \param[in]  ar_len          Number of elements in the array.
 *
 * \see A1_NbPut, A1_NbPutV, A1_NbMultiPut, A1_NbMultiPutS, A1_NbMultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_PutV(int target, A1_iov_t *iov_ar, int ar_len);

/**
 * \brief Non-Blocking copy of non-contiguous data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  iov_ar          Array of io vectors. Each vector represents a set of chunks of same size.
 * \param[in]  ar_len          Number of elements in the array.
 * \param[out] handle          Opaque A1 handle
 *
 * \see A1_NbPut, A1_NbPutV, A1_NbMultiPut, A1_NbMultiPutS, A1_NbMultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbPutV(int target, A1_iov_t *iov_ar, int ar_len, A1_handle_t handle);

/**
 * \brief Blocking accumulate of contiguous data from local memory onto remote memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (local) source memory.
 * \param[in]  target_ptr    Starting address in the (remote) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 * \param[in]  a1_type       Datatype of buffer and scaling factor.
 * \param[in]  scaling       Factor for scaling source.
 *
 * \see A1_Put, A1_Copy, A1_CopyAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_PutAcc(int target,
              void* source_ptr,
              void* target_ptr,
              int bytes,
              A1_datatype_t a1_type,
              void* scaling);

/**
 * \brief Non-Blocking accumulate of contiguous data from local memory onto remote memory.
 * 
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (local) source memory.
 * \param[in]  target_ptr    Starting address in the (remote) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 * \param[in]  a1_type       Datatype of buffer and scaling factor.
 * \param[in]  scaling       Factor for scaling source
 * \param[out] handle        Opaque A1 handle 
 *
 * \see A1_Put, A1_Copy, A1_CopyAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbPutAcc(int target,
                void* source_ptr,
                void* target_ptr,
                int bytes,
                A1_datatype_t a1_type,
                void* scaling,
                A1_handle_t handle);

/**
 * \brief Blocking accumulate of contiguous data from local memory to remote memory.
 *
 * \note A1_MultiPut can be used for single-target non-contiguous put as well,
 *       but the implementation may be far from optimal relative to A1_PutS
 *       and A1_PutV.
 *
 * \param[out] rc            The error code.
 * \param[in]  count         Number of operations to be performed
 * \param[in]  targets       Vector of remote process ranks.
 * \param[in]  source_ptr    Vector of starting addresses in the (local) source memory.
 * \param[in]  target_ptr    Vector of starting addresses in the (remote) target memory.
 * \param[in]  bytes         Vector of quantity of data to transfer in bytes.
 * \param[in]  a1_type       Datatype of buffer and scaling factor.
 * \param[in]  scaling       Factor for scaling source.
 *
 * \see A1_Put
 *
 * \ingroup DATA_TRANSFER
 */

int A1_MultiPutAcc(int count,
                   int *targets,
                   void* *source_ptr,
                   void* *target_ptr,
                   int *bytes,
                   A1_datatype_t a1_type,
                   void* scaling);

/**
 * \brief Nonblocking accumulate of contiguous data from local memory to remote memory.
 *
 * \note A1_MultiPut can be used for single-target non-contiguous put as well,
 *       but the implementation may be far from optimal relative to A1_PutS
 *       and A1_PutV.
 *
 * \param[out] rc            The error code.
 * \param[in]  count         Number of operations to be performed
 * \param[in]  targets       Vector of remote process ranks.
 * \param[in]  source_ptr    Vector of starting addresses in the (local) source memory.
 * \param[in]  target_ptr    Vector of starting addresses in the (remote) target memory.
 * \param[in]  bytes         Vector of quantity of data to transfer in bytes.
 * \param[in]  a1_type       Datatype of buffer and scaling factor.
 * \param[in]  scaling       Factor for scaling source.
 * \param[out] handle        Opaque A1 handle
 *
 * \see A1_NbPut, A1_MultiPut
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbMultiPutAcc(int count,
                     int *targets,
                     void* *source_ptr,
                     void* *target_ptr,
                     int *bytes,
                     A1_datatype_t a1_type,
                     void* scaling,
                     A1_handle_t handle);

/**
 * \brief Blocking accumulate of strided data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  stride_levels   The number of levels of stride.
 * \param[in]  block_sizes     Block size in each dimension in bytes.
 * \param[in]  source_ptr      Starting address in the (local) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at source in bytes.
 * \param[in]  target_ptr      Starting address in the (remote) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at target in bytes.
 * \param[in]  a1_type         Type of data and scaling factor
 * \param[in]  *scaling        Scaling factor in the accumulate operation. 
 *
 * \see A1_Put, A1_PutS, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_PutAccS(int target,
               int stride_levels,
               int *block_sizes,
               void* source_ptr,
               int *src_stride_ar,
               void* target_ptr,
               int *trg_stride_ar,
               A1_datatype_t a1_type,
               void* scaling);

/**
 * \brief Non-Blocking accumulate of strided data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  stride_levels   The number of levels of stride.
 * \param[in]  block_sizes     Block size in each dimension in bytes.
 * \param[in]  source_ptr      Starting address in the (local) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at source in bytes.
 * \param[in]  target_ptr      Starting address in the (remote) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at target in bytes.
 * \param[in]  a1_type         Type of data and scaling factor
 * \param[in]  *scaling        Scaling factor in the accumulate operation. 
 * \param[out] handle          Opaque A1 handle
 *
 * \see A1_Put, A1_PutS, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbPutAccS(int target,
                 int stride_levels,
                 int *block_sizes,
                 void* source_ptr,
                 int *src_stride_ar,
                 void* target_ptr,
                 int *trg_stride_ar,
                 A1_datatype_t a1_type,
                 void* scaling,
                 A1_handle_t handle);

/**
 * \brief Blocking copy of contiguous data from local memory to remote memory.
 *
 * \note This call must be use the same stride-level across all targets.
 *
 * \param[out] rc              The error code.
 * \param[in]  count           Number of operations to be performed
 * \param[in]  targets         Vector of remote process ranks.
 * \param[in]  block_sizes     Vector of block sizes in each dimension in bytes.
 * \param[in]  stride_levels   Number of levels of stride.
 * \param[in]  source_ptr      Vector of starting in the (local) source memory.
 * \param[in]  src_stride_ar   Vector of arrays of stride distances at source in bytes.
 * \param[in]  target_ptr      Vector of starting in the (remote) target memory.
 * \param[in]  trg_stride_ar   Vector of arrays of stride distances at target in bytes.
 * \param[in]  a1_type         Type of data and scaling factor
 * \param[in]  *scaling        Scaling factor in the accumulate operation.
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_MultiPutAccS(int count,
                    int *targets,
                    int stride_levels,
                    int* *block_sizes,
                    void* source_ptr,
                    int *src_stride_ar,
                    void* target_ptr,
                    int *trg_stride_ar,
                    A1_datatype_t a1_type,
                    void* scaling);

/**
 * \brief Nonblocking copy of contiguous data from local memory to remote memory.
 *
 * \note This call must be use the same stride-level across all targets.
 *
 * \param[out] rc              The error code.
 * \param[in]  count           Number of operations to be performed
 * \param[in]  targets         Vector of remote process ranks.
 * \param[in]  block_sizes     Vector of block sizes in each dimension in bytes.
 * \param[in]  stride_levels   Number of levels of stride.
 * \param[in]  source_ptr      Vector of starting in the (local) source memory.
 * \param[in]  src_stride_ar   Vector of arrays of stride distances at source in bytes.
 * \param[in]  target_ptr      Vector of starting in the (remote) target memory.
 * \param[in]  trg_stride_ar   Vector of arrays of stride distances at target in bytes.
 * \param[in]  a1_type         Type of data and scaling factor
 * \param[in]  *scaling        Scaling factor in the accumulate operation.
 * \param[out] handle          Opaque A1 handle
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbMultiPutAccS(int count,
                      int *targets,
                      int stride_levels,
                      int* *block_sizes,
                      void* source_ptr,
                      int *src_stride_ar,
                      void* target_ptr,
                      int *trg_stride_ar,
                      A1_datatype_t a1_type,
                      void* scaling,
                      A1_handle_t handle);

/**
 * \brief Blocking accumulate of non-contiguous data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  iov_ar          Array of io vectors. Each vector represents a set of
 *                             chunks of same size.
 * \param[in]  ar_len          Number of elements in the array.
 * \param[in]  a1_type         Type of data and scaling factor
 * \param[in]  *scaling        Scaling factor in the accumulate operation. 
 * 
 * \see A1_NbPut, A1_NbPutV, A1_NbMultiPut, A1_NbMultiPutS, A1_NbMultiPutV
 * 
 * \ingroup DATA_TRANSFER
 */

int A1_PutAccV(int target,
               A1_iov_t *iov_ar,
               int ar_len,
               A1_datatype_t a1_type,
               void* scaling);

/**
 * \brief Non-Blocking accumulate of non-contiguous data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  iov_ar          Array of io vectors. Each vector represents a set of
 *                             chunks of same size.
 * \param[in]  ar_len          Number of elements in the array.
 * \param[in]  a1_type         Type of data and scaling factor
 * \param[in]  *scaling        Scaling factor in the accumulate operation.
 * \param[out] handle          Opaque A1 handle
 *
 * \see A1_NbPut, A1_NbPutV, A1_NbMultiPut, A1_NbMultiPutS, A1_NbMultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbPutAccV(int target,
                 A1_iov_t *iov_ar,
                 int ar_len,
                 A1_datatype_t a1_type,
                 void* scaling,
                 A1_handle_t handle);

/**
 * \brief Blocking remote modify of non-contiguous data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  iov_ar          Array of io vectors. Each vector represents a set of
 *                             chunks of same size.
 * \param[in]  ar_len          Number of elements in the array.
 * \param[in]  a1_op           Reduce operation
 * \param[in]  a1_type         Type of data and scaling factor
 *
 * \see A1_NbPut, A1_NbPutV, A1_NbMultiPut, A1_NbMultiPutS, A1_NbMultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_PutModV(int target,
               A1_iov_t *iov_ar,
               int ar_len,
               A1_reduce_op_t a1_op,
               A1_datatype_t a1_type);

/**
 * \brief Blocking copy of contiguous data from remote memory to local memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (remote) source memory.
 * \param[in]  target_ptr    Starting address in the (local) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 *
 * \see A1_NbGet, A1_Put, A1_Copy
 *
 * \ingroup DATA_TRANSFER
 */

int A1_Get(int target, void* source_ptr, void* target_ptr, int bytes);

/**
 * \brief Non-Blocking copy of contiguous data from remote memory to local memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (remote) source memory.
 * \param[in]  target_ptr    Starting address in the (local) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 * \param[out] handle        Opaque handle for the request
 *
 * \see A1_Get, A1_Put, A1_Copy
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbGet(int target,
             void* source_ptr,
             void* target_ptr,
             int bytes,
             A1_handle_t handle);

/**
 * \brief Blocking copy of contiguous data from remote memory onto local memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  count         Number of operations to be performed
 * \param[in]  target        Vector of remote process ranks.
 * \param[in]  source_ptr    Vector of starting address in the (remote) source memory.
 * \param[in]  target_ptr    Vector of starting address in the (local) target memory.
 * \param[in]  bytes         Vector of data to transfer from each target in bytes.
 *
 * \see A1_Get, A1_MultiPut, A1_Copy
 *
 * \ingroup DATA_TRANSFER
 */

int A1_MultiGet(int count,
                int *target,
                void* *source_ptr,
                void* *target_ptr,
                int *bytes);

/**
 * \brief Nonblocking copy of contiguous data from remote memory onto local memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  count         Number of operations to be performed
 * \param[in]  target        Vector of remote process ranks.
 * \param[in]  source_ptr    Vector of starting address in the (remote) source memory.
 * \param[in]  target_ptr    Vector of starting address in the (local) target memory.
 * \param[in]  bytes         Vector of data to transfer from each target in bytes.
 * \param[out] handle        Opaque A1 handle
 *
 * \see A1_Get, A1_MultiPut, A1_Copy
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbMultiGet(int count,
                  int *target,
                  void* *source_ptr,
                  void* *target_ptr,
                  int *bytes,
                  A1_handle_t handle);

/**
 * \brief Blocking copy of strided data from remote memory to local memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  source_ptr      Starting address in the (remote) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at (remote process) source in bytes.
 * \param[in]  target_ptr      Starting address in the (local) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at (local process) target in bytes.
 * \param[in]  count           Block size in each dimension in bytes.
 * \param[in]  stride_levels   The number of levels of stride.
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_GetS(int target,
            int stride_levels,
            int *block_sizes,
            void* source_ptr,
            int *src_stride_ar,
            void* target_ptr,
            int *trg_stride_ar);

/**
 * \brief Non-Blocking copy of strided data from remote memory to local memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  source_ptr      Starting address in the (remote) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at (remote process) source in bytes.
 * \param[in]  target_ptr      Starting address in the (local) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at (local process) target in bytes.
 * \param[in]  count           Block size in each dimension in bytes.
 * \param[in]  stride_levels   The number of levels of stride.
 * \param[out] handle          Opaque A1 handle
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbGetS(int target,
              int stride_levels,
              int *block_sizes,
              void* source_ptr,
              int *src_stride_ar,
              void* target_ptr,
              int *trg_stride_ar,
              A1_handle_t handle);

/**
 * \brief Blocking copy of stided data from remote memory to local memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  count           Number of operations to be performed
 * \param[in]  target          Rank of the remote process.
 * \param[in]  source_ptr      Starting address in the (remote) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at (remote process) source in bytes.
 * \param[in]  target_ptr      Starting address in the (local) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at (local process) target in bytes.
 * \param[in]  count           Block size in each dimension in bytes.
 * \param[in]  stride_levels   The number of levels of stride.
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_MultiGetS(int target_count,
                 int *target,
                 int stride_levels,
                 int **count,
                 void* *source_ptr,
                 int **src_stride_ar,
                 void* *target_ptr,
                 int **trg_stride_ar);

/**
 * \brief Blocking copy of stided data from remote memory to local memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  count           Number of operations to be performed
 * \param[in]  target          Rank of the remote process.
 * \param[in]  source_ptr      Starting address in the (remote) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at (remote process) source in bytes.
 * \param[in]  target_ptr      Starting address in the (local) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at (local process) target in bytes.
 * \param[in]  count           Block size in each dimension in bytes.
 * \param[in]  stride_levels   The number of levels of stride.
 * \param[out] handle          Opaque A1 handle
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbMultiGetS(int target_count,
                   int *target,
                   int stride_levels,
                   int **count,
                   void* *source_ptr,
                   int **src_stride_ar,
                   void* *target_ptr,
                   int **trg_stride_ar,
                   A1_handle_t handle);

/**
 * \brief Blocking copy of non-contiguous data from remote memory to local memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  iov_ar          Array of io vectors. Each vector represents a set of
 *                             chunks of same size.
 * \param[in]  ar_len          Number of elements in the array.
 *
 * \see A1_NbPut, A1_NbPutV, A1_NbMultiPut, A1_NbMultiPutS, A1_NbMultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_GetV(int target, A1_iov_t *iov_ar, int ar_len);

/**
 * \brief Non-Blocking copy of non-contiguous data from remote memory to local memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  iov_ar          Array of io vectors. Each vector represents a set of
 *                             chunks of same size.
 * \param[in]  ar_len          Number of elements in the array.
 * \param[out] handle          Opaque A1 handle
 *
 * \see A1_NbPut, A1_NbPutV, A1_NbMultiPut, A1_NbMultiPutS, A1_NbMultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbGetV(int target, A1_iov_t *iov_ar, int ar_len, A1_handle_t handle);

/**
 * \brief Blocking get-and-accumulate operation (aka RMW) on arbitrary data.
 *        This operation is message-wise atomic.
 *
 * \warning Obviously, the user cannot mix RMW with other operations without
 *          proper synchronization.
 *
 * \param[out] rc               The error code.
 * \param[in]  target           Rank of the target process.
 * \param[in]  source_ptr_in    Pointer of modification data at source process.
 * \param[in]  source_ptr_out   Pointer of original read data at source process.
 * \param[in]  target_ptr       Pointer of modified data at target process.
 * \param[in]  bytes            Number of bytes to update.
 * \param[in]  op               Operation to be performed.
 * \param[in]  a1_type          Type of data and value.
 *
 * \ingroup DATA_TRANSFER
 */

int A1_Rmw(int target,
           void* source_ptr_in,
           void* source_ptr_out,
           void* target_ptr,
           int bytes,
           A1_atomic_op_t op,
           A1_datatype_t a1_type);

/**
 * \brief Non-blocking get-and-accumulate operation (aka RMW) on arbitrary data.
 *        This operation is message-wise atomic.
 *
 * \warning Obviously, the user cannot mix RMW with other operations without
 *          proper synchronization.
 *
 * \param[out] rc               The error code.
 * \param[in]  target           Rank of the target process.
 * \param[in]  source_ptr_in    Pointer of modification data at source process.
 * \param[in]  source_ptr_out   Pointer of original read data at source process.
 * \param[in]  target_ptr       Pointer of modified data at target process.
 * \param[in]  bytes            Number of bytes to update.
 * \param[in]  op               Operation to be performed.
 * \param[in]  a1_type          Type of data and value.
 * \param[out] handle          Opaque A1 handle
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbRmw(int target,
             void* source_ptr_in,
             void* source_ptr_out,
             void* target_ptr,
             int bytes,
             A1_atomic_op_t op,
             A1_datatype_t a1_type,
             A1_handle_t handle);

/**
 * \brief Blocking copy of contiguous data from remote memory to remote memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  source        Rank of the (remote) source process.
 * \param[in]  target        Rank of the (remote) target process.
 * \param[in]  source_ptr    Starting address in the (remote) source memory.
 * \param[in]  target_ptr    Starting address in the (remote) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 *
 * \see A1_Put, A1_Get
 *
 * \ingroup DATA_TRANSFER
 */

int A1_Copy(int source,
            int target,
            void* source_ptr,
            void* target_ptr,
            int bytes);

/**
 * \brief Blocking accumulate of contiguous data from remote memory onto remote memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  source        Rank of the (remote) source process.
 * \param[in]  target        Rank of the (remote) target process.
 * \param[in]  source_ptr    Starting address in the (remote) source memory.
 * \param[in]  target_ptr    Starting address in the (remote) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 * \param[in]  a1_type       Amount of data to transfer in bytes.
 * \param[in]  scaling       Factor for scaling source
 *
 * \see A1_Put, A1_Get
 *
 * \ingroup DATA_TRANSFER
 */

int A1_CopyAcc(int source,
               int target,
               void* source_ptr,
               void* target_ptr,
               int bytes,
               A1_datatype_t a1_type,
               void* scaling);

/* FIXME: More API functions to come */

/* ********************************************************************** */
/*                                                                        */
/*               A1 external API - synchronization and completion         */
/*                                                                        */
/* ********************************************************************** */

/**
 * \brief On return, this call ensures that all processes within the entire group
 *        have reached this point in the program.
 *
 *        This operation is collective and blocking.
 *
 * \param[out] rc            The error code.
 * \param[in] group          Group of processes to synchronize.
 *
 * \see A1_Flush, A1_AllFlush, A1_Sync.
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Barrier_group(A1_group_t* group);

/**
 * \brief When the handle state is A1_TRUE, all processes within the entire group
 *        have reached this point in the program.
 *
 *        This operation is collective and non-blocking.
 *
 * \param[out] rc            The error code.
 * \param[in] group          Group of processes to synchronize.
 *
 * \see A1_Flush, A1_AllFlush, A1_Sync.
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_NbBarrier_group(A1_group_t* group, A1_handle_t handle);

/**
 * \brief On return, this call ensures that all outstanding put or accumulate
 *        operations are complete remotely within the entire group.
 *
 *        This operation is collective and blocking.  It has the effect of
 *        A1_Flush_group called from every process in the group followed by A1_Barrier_group.
 *
 * \param[out] rc            The error code.
 * \param[in] group          Group of processes to synchronize.
 *
 * \see A1_GlobalSync, A1_GroupBarrier, A1_Flush_group.
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Sync_group(A1_group_t* group);

/**
 * \brief When the handle state is A1_TRUE, all outstanding put or accumulate
 *        operations are complete remotely within the entire group.
 *
 *        This operation is collective and blocking.  It has the effect of
 *        A1_NbFlush_group called from every process in the group followed by A1_NbBarrier_group.
 *
 * \param[out] rc            The error code.
 * \param[in] group          Group of processes to synchronize.
 *
 * \see A1_GlobalSync, A1_GroupBarrier, A1_Flush_group.
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_NbSync_group(A1_group_t* group, A1_handle_t handle);

/**
 * \brief On return, this call ensures that all blocking and non-blocking put
 *        and accumulate operations sent to the target process have completed remotely.
 *
 *        This operation is local and blocking.
 *
 * \param[out] rc            The error code.
 * \param[in]  proc          Rank of the remote process.
 *
 * \see A1_Flush_group, A1_Sync
 *
 * \ingroup COMPLETION
 */

int A1_Flush(int proc);

/**
 * \brief When the handle state is A1_TRUE, all blocking and non-blocking put
 *        and accumulate operations sent to the target process have completed remotely.
 *
 *        This operation is local and non-blocking.
 *
 * \param[out] rc            The error code.
 * \param[in]  proc          Rank of the remote process.
 *
 * \see A1_Flush_group, A1_Sync
 *
 * \ingroup COMPLETION
 */

int A1_NbFlush(int proc, A1_handle_t handle);

/**
 * \brief On return, this call ensures that all blocking and non-blocking put
 *        and accumulate operations have completed remotely at the processes given in the list.
 *
 *        This operation is local and blocking.
 *
 * \param[out] rc                The error code.
 * \param[in] count              Number of processes in vector.
 * \param[in] proc_list          Vector of processes to flush against.
 *
 * \see A1_Flush, A1_Flush_group
 *
 * \ingroup COMPLETION
 */

int A1_Flush_list(int count, int *proc_list);

/**
 * \brief When the handle state is A1_TRUE, all blocking and non-blocking put
 *        and accumulate operations have completed remotely at the processes given in the list.
 *
 *        This operation is local and blocking.
 *
 * \param[out] rc                The error code.
 * \param[in] count              Number of processes in vector.
 * \param[in] proc_list          Vector of processes to flush against.
 *
 * \see A1_Flush, A1_Flush_group
 *
 * \ingroup COMPLETION
 */

int A1_NbFlush_list(int count, int *proc_list, A1_handle_t handle);

/**
 * \brief On return, this call ensures that all blocking and non-blocking put
 *        and accumulate operations have completed remotely at the processes in the group.
 *
 *        This operation is local and blocking.
 *
 * \param[out] rc                The error code.
 * \param[in] count              Number of processes in vector.
 * \param[in] proc_list          List of processes to flush against.
 *
 * \see A1_Flush, A1_Sync
 *
 * \ingroup COMPLETION
 */

int A1_Flush_group(A1_group_t* group);

/**
 * \brief When the handle state is A1_TRUE, all blocking and non-blocking put
 *        and accumulate operations have completed remotely at the processes in the group.
 *
 *        This operation is local and blocking.
 *
 * \param[out] rc                The error code.
 * \param[in] count              Number of processes in vector.
 * \param[in] proc_list          List of processes to flush against.
 *
 * \see A1_Flush, A1_Sync
 *
 * \ingroup COMPLETION
 */

int A1_NbFlush_group(A1_group_t* group, A1_handle_t handle);

/**
 * \brief Blocks on completion of all non-blocking handles.
 *
 * \param[out] rc                The error code.
 *
 * \see A1_handle_t, A1_Wait_handle_list, A1_Test_handle
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Wait_handle_all(void);

/**
 * \brief Blocks on completion of a non-blocking handle.
 *
 * \param[in] handle      Non-blocking handle upon which to be waited.
 *
 * \see A1_handle_t, A1_Wait_handle_list, A1_Test_handle
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Wait_handle(A1_handle_t handle);

/**
 * \brief Blocks on completion of all elements in a vector of non-blocking handles.
 *
 * \param[in] count        Number of handles in vector.
 * \param[in] handles      Vector of non-blocking handles upon which to be waited.
 *
 * \see A1_handle_t, A1_Wait_handle, A1_Test_handle_list
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Wait_handle_list(int count, A1_handle_t* handles);

/**
 * \brief Blocks on completion of a non-blocking handle.
 *
 * \param[in]  handle        Non-blocking handle upon which to be waited.
 * \param[out] completed     Handle status.
 *
 * \see A1_handle_t, A1_Wait_handle, A1_Test_handle_list
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Test_handle(A1_handle_t handle, A1_bool_t* completed);

/**
 * \brief Blocks on completion of all elements in a vector of non-blocking handles.
 *
 * \param[in]  count        Number of handles in vector.
 * \param[in]  handles      Vector of non-blocking handles upon which to be waited.
 * \param[out] completed    Vector of handle statuses.
 *
 * \see A1_handle_t, A1_Test_handle, A1_Wait_handle_list
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Test_handle_list(int count, A1_handle_t *handles, A1_bool_t* *completed);

/**
 * \brief Resets a non-blocking handle.
 *
 * \param[in] handle      Non-blocking handle to be reset.
 *
 * \see A1_handle_t, A1_Reset_handle_list
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Reset_handle(A1_handle_t* handle);

/**
 * \brief Resets a non-blocking handle.
 *
 * \param[in]  count        Number of handles in vector.
 * \param[in] handle      Non-blocking handle to be reset.
 *
 * \see A1_handle_t, A1_Reset_handle
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Reset_handle_list(int count, A1_handle_t* handle);

/* ********************************************************************** */
/*                                                                        */
/*               A1 external API - many-to-many operations                */
/*                                                                        */
/* ********************************************************************** */

/**
 * \brief
 *
 * \param[in] group          Group of processes.
 *
 * \see
 *
 * \ingroup MANYTOMANY
 */

int A1_Multicast_group(A1_group_t* group,
                       int root,
                       int count,
                       A1_datatype_t a1_type,
                       void* buffer);

/**
 * \brief
 *
 * \param[in] group          Group of processes.
 *
 * \see
 *
 * \ingroup MANYTOMANY
 */

int A1_NbMulticast_group(A1_group_t* group,
                         int root,
                         int count,
                         A1_datatype_t a1_type,
                         void* buffer,
                         A1_handle_t a1_handle);

/**
 * \brief
 *
 * \param[in] group          Group of processes.
 *
 * \see
 *
 * \ingroup MANYTOMANY
 */

int A1_Reduce_group(A1_group_t* group,
                    int root,
                    int count,
                    A1_reduce_op_t a1_op,
                    A1_datatype_t a1_type,
                    void* in,
                    void* out);

/**
 * \brief
 *
 * \param[in] group          Group of processes.
 *
 * \see
 *
 * \ingroup MANYTOMANY
 */

int A1_NbReduce_group(A1_group_t* group,
                      int root,
                      int count,
                      A1_reduce_op_t a1_op,
                      A1_datatype_t a1_type,
                      void* in,
                      void* out,
                      A1_handle_t a1_handle);

/**
 * \brief
 *
 * \param[in] group          Group of processes.
 *
 * \see
 *
 * \ingroup MANYTOMANY
 */

int A1_Allreduce_group(A1_group_t* group,
                       int count,
                       A1_reduce_op_t a1_op,
                       A1_datatype_t a1_type,
                       void* in,
                       void* out);

/**
 * \brief
 *
 * \param[in] group          Group of processes.
 *
 * \see
 *
 * \ingroup MANYTOMANY
 */

int A1_NbAllreduce_group(A1_group_t* group,
                         int count,
                         A1_reduce_op_t a1_op,
                         A1_datatype_t a1_type,
                         void* in,
                         void* out,
                         A1_handle_t a1_handle);

/**
 * \brief
 *
 * \param[in] group          Group of processes.
 *
 * \see
 *
 * \ingroup MANYTOMANY
 */

int A1_Bcast_group(A1_group_t* group,
                   int root,
                   int bytes,
                   void* buffer);

/**
 * \brief
 *
 * \param[in] group          Group of processes.
 *
 * \see
 *
 * \ingroup MANYTOMANY
 */

int A1_NbBcast_group(A1_group_t* group,
                     int root,
                     int count,
                     void* buffer,
                     A1_handle_t a1_handle);

/**
 * \brief
 *
 * \param[in] group          Group of processes.
 *
 * \see
 *
 * \ingroup MANYTOMANY
 */

int A1_Manytomany_group(A1_group_t* in_group,
                        A1_group_t* out_group,
                        int count,
                        A1_datatype_t a1_type,
                        void* in,
                        void* out);

/**
 * \brief
 *
 * \param[in] group          Group of processes.
 *
 * \see
 *
 * \ingroup MANYTOMANY
 */

int A1_NbManytomany_group(A1_group_t* in_group,
                          A1_group_t* out_group,
                          int count,
                          A1_datatype_t a1_type,
                          void* in,
                          void* out,
                          A1_handle_t a1_handle);

/* FIXME: More API functions to come */

/*! @} */

/* ********************************************************************** */
/*                                                                        */
/*               A1 version information                                   */
/*                                                                        */
/* ********************************************************************** */

/* A1_VERSION is the version string. A1_NUMVERSION is the
 * numeric version that can be used in numeric comparisons.
 *
 * A1_VERSION uses the following format:
 * Version: [MAJ].[MIN].[REV][EXT][EXT_NUMBER]
 * Example: 1.0.7rc1 has
 *          MAJ = 1
 *          MIN = 0
 *          REV = 7
 *          EXT = rc
 *          EXT_NUMBER = 1
 *
 * A1_NUMVERSION will convert EXT to a format number:
 *          ALPHA (a) = 0
 *          BETA (b)  = 1
 *          RC (rc)   = 2
 *          PATCH (p) = 3
 * Regular releases are treated as patch 0
 *
 * Numeric version will have 1 digit for MAJ, 2 digits for MIN, 2
 * digits for REV, 1 digit for EXT and 2 digits for EXT_NUMBER. So,
 * 1.0.7rc1 will have the numeric version 10007201.
 */
#define A1_VERSION "@A1_VERSION@"
#define A1_NUMVERSION @A1_NUMVERSION@

#define A1_RELEASE_TYPE_ALPHA  0
#define A1_RELEASE_TYPE_BETA   1
#define A1_RELEASE_TYPE_RC     2
#define A1_RELEASE_TYPE_PATCH  3

#define A1_CALC_VERSION(MAJOR, MINOR, REVISION, TYPE, PATCH) \
    (((MAJOR) * 10000000) + ((MINOR) * 100000) + ((REVISION) * 1000) + ((TYPE) * 100) + (PATCH))

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* A1_H_INCLUDED */
